"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const domElements_1 = __importDefault(require("./domElements"));
const tailwindcss_classnames_1 = require("tailwindcss-classnames");
const cleanTemplate = (template, inheritedClasses = "") => {
    const newClasses = template
        .toString()
        .trim()
        .replace(/\s{2,}/g, " ")
        .split(" ")
        .filter((c) => c !== ",");
    const inheritedClassesArray = inheritedClasses ? inheritedClasses.split(" ") : [];
    return tailwindcss_classnames_1.classnames(...inheritedClassesArray
        .concat(newClasses)
        .filter((c) => c !== " ")
        .filter((v, i, arr) => arr.indexOf(v) === i)).split(" ");
};
function parseTailwindClassNames(template, ...templateElements) {
    return template
        .reduce((sum, n, index) => {
        const templateElement = templateElements[index];
        if (typeof templateElement === "string") {
            return `${sum} ${n} ${templateElement}`;
        }
        return `${sum} ${n}`;
    }, "")
        .trim()
        .replace(/\s{2,}/g, " ");
}
const functionTemplate = (Element) => (template, ...templateElements) => react_1.default.forwardRef(({ children, ...props }, ref) => (react_1.default.createElement(Element, Object.assign({}, props, { ref: ref, className: parseTailwindClassNames(cleanTemplate(template, props.className), ...templateElements.map((t) => t(props))) }), children)));
const intrinsicElements = domElements_1.default.reduce((acc, domElement) => ({
    ...acc,
    [domElement]: functionTemplate(domElement)
}), {});
const tw = Object.assign((Component) => functionTemplate(Component), intrinsicElements);
exports.default = tw;
//# sourceMappingURL=tailwind.js.map